## Symbols
```
// Keywords
<-  // Used on for-comprehensions, to separate pattern from generator
=>  // Used for function types, function literals and import renaming

// Reserved
( )        // Delimit expressions and parameters
[ ]        // Delimit type parameters
{ }        // Delimit blocks
.          // Method call and path separator
// /* */   // Comments
#          // Used in type notations
:          // Type ascription or context bounds
<: >: <%   // Upper, lower and view bounds
<? <!      // Start token for various XML elements
" """      // Strings
'          // Indicate symbols and characters
@          // Annotations and variable binding on pattern matching
`          // Denote constant or enable arbitrary identifiers
,          // Parameter separator
;          // Statement separator
_*         // vararg expansion
_          // Many different meanings
```

## Underscore
```
import scala._    // Wild card -- all of Scala is imported
import scala.{ Predef => _, _ } // Exception, everything except Predef
def f[M[_]]       // Higher kinded type parameter
def f(m: M[_])    // Existential type
_ + _             // Anonymous function placeholder parameter
m _               // Eta expansion of method into method value
m(_)              // Partial function application
_ => 5            // Discarded parameter
case _ =>         // Wild card pattern -- matches anything
f(xs: _*)         // Sequence xs is passed as multiple parameters to f(ys: T*)
case Seq(xs @ _*) // Identifier xs is bound to the whole matched sequence
```


# Identifiers
> One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to write a declaration like this, “val name_: Int = 1”, you’ll get a compiler error. The compiler will think you are trying to declare a val named “name_:”. To get this to compile, you would need to insert an extra space before the colon, as in: “val name_ : Int = 1”.

The identifier :-> would be represented internally as $colon$minus$greater. If you ever wanted to access this identifier from Java code, you’d need to use this internal representation.

## Alphanumeric Identifier
Starts with letter or underscore, which can be followed by further letters, digits, or underscores. Identifiers which start with $ are reserved for scala identifiers.

## Operator identifier
Consists of one or more operator characters. Operator characters are printable ASCII characters such as +, :, ?, ~ or # 

Examples `+  ++ ::: <?>  :->`

## Mixed identifier
Consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier. For example, unary_+ used as a method name defines a unary + operator. Or, myvar_= used as method name defines an assignment operator. In addition, the mixed identifier form myvar_= is generated by the Scala compiler to support properties; more on that in Chapter 18.

## Literal identifier
 is an arbitrary string enclosed in back ticks ```(` . . . `)``` Some examples of literal identifiers are:
```
`x`  `<clinit>`  `yield` 
```
The idea is that you can put any string that’s accepted by the runtime
as an identifier between back ticks. The result is always a Scala identifier.
This works even if the name contained in the back ticks would be a Scala
reserved word. A typical use case is accessing the static yield method in
Java’s Thread class. You cannot write Thread.yield() because yield is
a reserved word in Scala. However, you can still name the method in back
ticks, e.g., 
```
Thread.`yield`();
```

# Literals
## Character Literals
Character literals are composed of any Unicode character between single
quotes e. g 

1. val a='A';
2. val c = '\101' 
The octal number must be between '\0' and '\377'.
3. val d = '\u0041' 
Unicode character consisting of four hex digits and preceded by a \u
4. scala> val B\u0041\u0044 = 1
BAD: Int = 1


Literal Meaning

* \n line feed (\u000A)
* \b backspace (\u0008)
* \t tab (\u0009)
* \f form feed (\u000C)
* \r carriage return (\u000D)
* \" double quote (\u0022)
* \' single quote (\u0027)
* \\ backslash (\u005C)



## String Literals
```
println("""Welcome to Ultamix 3000.
	Type "HELP" for help.""")

println("""|Welcome to Ultamix 3000.
		|Type "HELP" for help.""".stripMargin)
```

## Symbol Literals
```
scala> updateRecordByName('favoriteAlbum, "OK Computer")
scala> val s = 'aSymbol
s: Symbol = 'aSymbol
scala> s.name
res20: String = aSymbol
```

# Operators are Methods
## Infix operators:
```
scala> (1).+(2)
scala> s indexOf 'o'
scala> s indexOf ('o', 5) // Scala invokes s.indexOf(’o’, 5)
```

Prefix operators:
The only identifiers that can be used as prefix operators are +, -, !, and ~.
```
-7 // (7).unary_-
```

## Postfix operators:
Postfix operators are methods that take no arguments, when they are invoked without a dot or parentheses.

The convention is that you include parentheses if the
method has side effects, such as println(), but you can leave them off if
the method has no side effects,

```
7 toLong
```

## Relational and Logical operations
Note
You may be wondering how short-circuiting can work given operators are
just methods. Normally, all arguments are evaluated before entering a
method, so how can a method avoid evaluating its second argument? The
answer is that all Scala methods have a facility for delaying the evaluation
of their arguments, or even declining to evaluate them at all. The facility is
called by-name parameters and is discussed in Section 9.5.

## Bitwise Operators
The bitwise methods are: bitwise-and (&), bitwise-or (|), and bitwise-xor (ˆ)
```
scala> 1 & 2
res24: Int = 0
scala> 1 | 2
res25: Int = 3
scala> 1 ˆ 3
res26: Int = 2
scala> ~1
res27: Int = -2
```
## Shift operators
```
scala> -1 >> 31
res28: Int = -1
scala> -1 >>> 31
res29: Int = 1
scala> 1 << 2
res30: Int = 4
```

## Object equality 
```
scala> List(1, 2, 3) == List(1, 2, 3)
scala> List(1, 2, 3) == List(4, 5, 6)
scala> List(1, 2, 3) == "hello"
scala> List(1, 2, 3) == null
scala> null == List(1, 2, 3)
```

Scala provides a facility for comparing reference equality, as well,
under the name eq. However, eq and its opposite, ne, only apply to
objects that directly map to Java objects. The full details about eq and
ne are given in Sections 11.1 and 11.2. 


## Operator Precedence
(all other special characters)
*/%
+-
:
=!
<>
&
ˆ
|
(all letters)
(all assignment operators) *=, -= , += etc


Any method that ends in a ‘:’ character is invoked on its right operand, passing in the left operand. Methods that end in any other character are the other way around. They are invoked on their left operand, passing in the right operand. So a * b yields a.*(b), but a ::: b yields b.:::(a).

a ::: b ::: c is treated as a ::: (b ::: c). But a * b * c, by contrast, is
treated as (a * b) * c.

## Rich wrappers
```
0 max 5 
0 min 5 
-2.7 abs 
-2.7 round 
1.5 isInfinity 
(1.0 / 0) isInfinity 
4 to 6 
"bob" capitalize 
"robert" drop 2 
```
